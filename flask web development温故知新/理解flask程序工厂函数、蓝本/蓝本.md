# 蓝本
摘自原书：
>转换成程序工厂函数的操作让定义路由变复杂了。在单脚本程序中，程序实例存在于全
局作用域中，路由可以直接使用 app.route 修饰器定义。但现在程序在运行时创建，只
有调用 create_app() 之后才能使用 app.route 修饰器，这时定义路由就太晚了。和路由
一样，自定义的错误页面处理程序也面临相同的困难，因为错误页面处理程序使用 app.
errorhandler 修饰器定义。
>
>幸好 Flask 使用蓝本提供了更好的解决方法。蓝本和程序类似，也可以定义路由。不同的
是，在蓝本中定义的路由处于休眠状态，直到蓝本注册到程序上后，路由才真正成为程序
的一部分。使用位于全局作用域中的蓝本时，定义路由的方法几乎和单脚本程序一样。
>
>和程序一样，蓝本可以在单个文件中定义，也可使用更结构化的方式在包中的多个模块中
创建。为了获得最大的灵活性，程序包中创建了一个子包，用于保存蓝本。示例 7-4 是这
个子包的构造文件，蓝本就创建于此。

## 初步理解：
为什么要使用蓝本？

程序工厂函数的出现使顶定义路由变得复杂了。

为什么变复杂了？

在单脚本程序中（程序中只有一个app），app处于全局作用域，路由可用app.route装饰，**但现在程序在运行时创建**，只用调用create_app()之后才能使用app.route，这时定义路由就太晚了。

优点：

在蓝本中定义的路由处于休眠状态，只有当蓝本被注册到程序中，路由才能发挥作用。
是为了激活注册在程序工厂函数中的app。

使用方法：

在相应app的`__init__.py`文件中定义：

```python
from flask import Blueprint
# 创建蓝本
main = Blueprint('main',__name__)#实例化blueprint类对象创建蓝本

#导入这两个模块，能把路由和错误处理关联起来
from . import views,errors #在末尾是为了避免循环导入依赖
```
2个必须指定参数：

- 蓝本的名字：第二个`main`
- 蓝本所在的包或者模块：`__name__`

创建好蓝本之后，就要在create_app中注册蓝本：
```
def create_app(config_name):
    #...
    
    #注册main蓝本
    from .main import main as main_blueprint
    app.register_blueprint(main_blueprint)

    return app
```

使用蓝本功能后发生的变化：

视图函数中：

- app.route要变成main.route,原因不用多说，修饰的app变了啊
- url_for()函数中的参数中的端点名要加命名空间
    eg：
    `return redirect(url_for('main.index'))`
    
    在原应用程序中，main可以省略，就变成了`.index`,如果重定向到了其他应用程序，那必须要写完整的端点名
- form表单类也要移到相应app下
